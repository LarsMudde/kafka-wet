using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace AspNetCore.Extensions.Streaming.Configuration
{
    /// <summary>
    /// See: https://github.com/edenhill/librdkafka/blob/0116fix/CONFIGURATION.md
    /// </summary>
    public class KafkaConfig
    {
        #region common settings

        /// <summary>
        /// A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. 
        /// </summary>
        public string[] BootstrapServers { get; set; }

        /// <summary>
        /// An id string to pass to the server when making requests.
        /// The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical
        /// application name to be included in server-side request logging.
        /// </summary>
        public string ClientId { get; set; }

        /// <summary>
        /// A comma-separated list of debug contexts to enable. Defaults to 'generic'.
        /// Available contexts: generic, broker, topic, metadata, feature, queue, msg, protocol, cgrp, security, fetch, interceptor, plugin, consumer, admin, eos or all
        /// </summary>
        public string DebugContexts { get; set; }

        /// <summary>
        /// Log level (according to syslog(3))
        /// </summary>
        public LogLevel? LogLevel { get; set; }

        /// <summary>
        /// The configuration controls the maximum amount of time the client will wait for the response of a request.
        /// </summary>
        public int? RequestTimeoutMs { get; set; }

        #endregion

        #region https://kafka.apache.org/documentation/#consumerconfigs

        /// <summary>
        /// The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if enable.auto.commit is set to true.
        /// </summary>
        public int? AutoCommitInterval { get; set; }

        /// <summary>
        /// What to do when there is no initial offset in Kafka or if the current offset does not
        /// exist any more on the server (e.g. because that data has been deleted)
        /// </summary>
        public AutoOffsetReset? AutoOffsetReset { get; set; }

        /// <summary>
        /// If true the consumer's offset will be periodically committed in the background.
        /// </summary>
        public bool? EnableAutoCommit { get; set; }

        /// <summary>
        /// A unique string that identifies the consumer group this consumer belongs to.
        /// </summary>
        public string GroupId { get; set; }

        /// <summary>
        /// The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. 
        /// </summary>
        public int? HeartbeatMs { get; set; }

        /// <summary>
        /// The timeout used to detect consumer failures when using Kafka's group management facility.
        /// </summary>
        public int? SessionTimeoutMs { get; set; }

        public Dictionary<string, object> GetConsumerConfig()
        {
            return new Dictionary<string, object>
            {
                {"auto.commit.interval.ms", AutoCommitInterval.GetValueOrDefault(5000)},
                {"auto.offset.reset", AutoOffsetReset.GetValueOrDefault(Configuration.AutoOffsetReset.Latest).ToString().ToLower()},
                {"bootstrap.servers", string.Join(",", BootstrapServers)},
                {"client.id", ClientId ?? $"{Assembly.GetEntryAssembly().FullName.ToLower()}-{Environment.MachineName.ToLower()}"},
                {"enable.auto.commit", EnableAutoCommit.GetValueOrDefault(false)},
                {"group.id", GroupId ?? $"{Assembly.GetEntryAssembly().GetName().Name.ToLower()}"},
                {"heartbeat.interval.ms", HeartbeatMs.GetValueOrDefault(3000)},
                {"request.timeout.ms", RequestTimeoutMs.GetValueOrDefault(30000)},
                {"session.timeout.ms", SessionTimeoutMs.GetValueOrDefault(10000)},
                {"debug", DebugContexts ?? "generic"},
                {"log_level", (int)LogLevel.GetValueOrDefault(Configuration.LogLevel.LOG_INFO)}
            };
        }

        #endregion

        #region https://kafka.apache.org/documentation/#producerconfigs

        /// <summary>
        /// The number of acknowledgments the producer requires the leader to have received before considering a request complete. 
        /// </summary>
        public Acks? Acks { get; set; }

        /// <summary>
        /// The compression type for all data generated by the producer.
        /// </summary>
        public CompressionType? CompressionType { get; set; }

        /// <summary>
        /// This setting accomplishes this by adding a small amount of artificial delay—that is, rather than
        /// immediately sending out a record the producer will wait for up to the given delay to allow other
        /// records to be sent so that the sends can be batched together.
        /// This setting defaults to 0 (i.e. no delay). Setting linger.ms=5, for example, would have the effect  of
        /// reducing the number of requests sent but would add up to 5ms of latency to records sent in the absence of load.
        /// </summary>
        public int? LingerMs { get; set; }

        /// <summary>
        /// Number of retries to resend any record whose send fails with a potentially transient error.
        /// Possible values: 0...10000000
        /// </summary>
        public int? Retries { get; set; }

        public Dictionary<string, object> GetProducerConfig()
        {
            return new Dictionary<string, object>
            {
                {"acks", (int) Acks.GetValueOrDefault(Configuration.Acks.One)},
                {"bootstrap.servers", string.Join(",", BootstrapServers)},
                {"client.id", ClientId ?? $"{Assembly.GetEntryAssembly().FullName.ToLower()}-{Environment.MachineName.ToLower()}"},
                {"compression.type", CompressionType.GetValueOrDefault(Configuration.CompressionType.None).ToString().ToLower()},
                {"linger.ms", LingerMs.GetValueOrDefault(0)},
                {"request.timeout.ms", RequestTimeoutMs.GetValueOrDefault(30000)},
                {"retries", Retries.GetValueOrDefault(10000000)},
                {"debug", DebugContexts ?? "generic"},
                {"log_level", (int)LogLevel.GetValueOrDefault(Configuration.LogLevel.LOG_INFO)}
            };
        }

        #endregion
    }

    public enum AutoOffsetReset
    {
        Latest,
        Earliest,
        None
    }

    public enum Acks
    {
        Zero = 0,
        One = 1,
        All = -1
    }

    public enum CompressionType
    {
        None,
        GZip,
        Snappy,
        LZ4,
        Zstd
    }

    [SuppressMessage("ReSharper", "InconsistentNaming")]
    public enum LogLevel
    {
        /// <summary>
        /// system is unusable
        /// </summary>
        LOG_EMERG = 0,

        /// <summary>
        /// action must be taken immediately
        /// </summary>
        LOG_ALERT = 1,

        /// <summary>
        /// critical conditions
        /// </summary>
        LOG_CRIT = 2,

        /// <summary>
        /// error conditions
        /// </summary>
        LOG_ERR = 3,

        /// <summary>
        /// warning conditions
        /// </summary>
        LOG_WARNING = 4,

        /// <summary>
        /// normal, but significant, condition
        /// </summary>
        LOG_NOTICE = 5,

        /// <summary>
        /// informational message
        /// </summary>
        LOG_INFO = 6,

        /// <summary>
        /// debug-level message
        /// </summary>
        LOG_DEBUG = 7
    }
}
